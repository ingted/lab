Java 学习笔记

使用Scanner类时必须import java.util.*，但使用System.out.println()不需要import

将一个double赋值给int所不允许的，除非有强制类型转化，同样因为会损失精度，double也不能直接赋值给float，而无精度损失的则行

对于0/0会抛出异常，而0.0/0.0则不会有异常（任何浮点运算都不会抛出异常，结果为NaN），对于1.0/0.0结果为Indifinty

println，print的唯一区别是print不会在最后加\n

java可以返回String

对于所有变量都要声明！所以在某个类实例化时非常麻烦，例：String aa= new String("hello world")

在java中可以实现成员方法重载（重复定义类的成员方法，这样可以让java自动判断参数类型然后调用不同方法）

在java类中有this关键字，与python中的self类似，不过由于java类中引用对象的成员变量时不需要加this，所以除非参数或局部变量与成员变量重名，否则一般不加this

java的变量寿命和块有关（例：
		for (int i;i<10;i++){
			System.out.println(i);
		}
		System.out.println(i);
		)
		这样编译会错，后一个i将找不到！

abstract类可以包含方法的具体实现

&运算符对于int会进行位运算，对于boolean会进行逻辑运算。而&&对于int不能运算，对于boolean进行短路逻辑运算！！！！！！！！！！！！

##########如果类没有构造函数那么创建对象时系统会调用默认的无参数构造函数，但一旦你定义了构造函数（不关是否有参数）系统就不会再调用默认的构造函数！！！

#########如果在子类构造方法中没有显式地调用super（无论有无参数）那么系统会自动调用super()，这只对构造函数有效！！！！！！！！！！！！！！！！！

#########引用变量的类型——而不是引用对象的类型——决定了什么成员可以被访问（所以父类对象的变量可以引用子类对象，但不能访问父类没有而子类有的成员）！！！！
			但当子类重写了父类方法时，父类对象的变量会根据引用子类对象的类型决定调用哪个版本的方法！！！！！！！！！！！！！

##########当类被加载时，所有static块会运行，所有static变量会被初始化，这两者顺序按其在类中的声明顺序运行！！！！

2010-9-8
super有两种用法：（1）调用父类的构造函数。（2）用于区别被子类屏蔽的成员，但这要求成员在父类中不为private

当某个父类有w这个公共成员变量是，如果没被子类屏蔽是子类对该变量访问可以用this.w也可以是super.w，这两者没区别

abstract方法只能在abstract类中，不能在非abstract类中

	包：
java会通过编译器为所有程序隐式引入java.lang

import不是必须的


2010-09-10
java2参考大全的第九章 包和接口跳过接口部分

当catch的exception有继承关系时要将子类放在前面，否则子类不会被catch


2010-09-11

父类对象变量可以引用子类对象，引用之后调用的方法只能是父类方法中已定义的，而调用时如果子类重写类方法那么就调用重写后的

int i=1,j=2;	System.out.println(i+j+"abc");	System.out.println("abc"+i+j);	+号运算符从左到右，所以结果为3abc,abc12

2009-09-17

对于类成员变量的初始化：如果成员为基本数据类型，则能被初始化，如果为类，则为null，局部变量不能初始化

2009-09-18

构造器：
	A a = new a();构造器要与类名相同，构造器无返回值
	类中可以没有构造器（jvm会自行产生缺省构造器），如果有带参构造器，则jvm就不会自动产生缺省构造器

构造器与一般方法的区别：

	不能有abstract，final，native，static，synchronzied修饰

this有三种用法：
	1：调用类的成员变量或方法
	2：在构造器中调用构造器
	3：在方法内部获得当前对象(当前正在调用类中方法的对象)引用

2009-09-19

String str = "abc";	这会在常量池中创建对象，如果常量池中已有"abc"则不创建而直接指向它，而new String("abc")则不会和其他东西比较，从而不会和其他对象的地址重复！！！

在编译时就确定的常量都分布在常量池，相同量都指向同一地址，所以
String s0="kvill"; 
String s1="kvill"; 
String s2="kv" + "ill"; 
System.out.println( s0==s1 ); //true
System.out.println( s0==s2 );//true
而如果
String s0="kvill"; 
String s1="kv"; 
String s2=s1 + "ill"; 
System.out.println( s0==s2 );//false
这是因为在编译期间不能确定s1的值，所以s2指向的不是常量值（详见深入Java核心 Java内存分配原理精讲）

2009-09-20

继承就相当于在编译时将父类的一些代码拷贝至子类。。。。

2009-09-21

当在构造器中通过this或super引用构造器时必须在第一句话，但引用其他方法时不一定。

当父类设置成员变量为private时，子类就无法使用super来引用
